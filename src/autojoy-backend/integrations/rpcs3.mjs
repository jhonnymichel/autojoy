import path from "path";
import fs from "fs";
import mmjoystick from "./rpcs3/mmjoystick.mjs";
import { loaders, savers } from "../../common/file.mjs";
import { user } from "../../common/settings.mjs";
import {
  getXinputJoystickType,
  getXinputVendorAndProductIds,
  hardwareInfo,
  isHardware,
} from "../../common/joystick.mjs";
import { createJoystickFromXinputDevice } from "../joystick.mjs";
import { getEvdevName, getFixedOldDeviceSDLName } from "./shared.mjs";

const configTemplates = loaders.yml("config-templates/rpcs3.yml");
const rpcs3Path = user.paths.rpcs3;
const inputProfile = "autojoy-autogenerated-profile";
const inputConfigFileName = resolveConfigPath(
  `input_configs/global/${inputProfile}.yml`,
);
const activeProfileFileName = resolveConfigPath(
  `input_configs/active_input_configurations.yml`,
);
// for microphone settings
const generalConfigFileName = resolveConfigPath(`config.yml`);
const customConfigsPath = resolveConfigPath(`custom_configs`);
const getActiveInputProfileObject = () => ({
  ["Active Configurations"]: {
    global: inputProfile,
  },
});

// identifier for each slot in the input settings
const playerIdentifiers = [
  "Player 1 Input",
  "Player 2 Input",
  "Player 3 Input",
  "Player 4 Input",
  "Player 5 Input",
  "Player 6 Input",
  "Player 7 Input",
];

// the input setting "Handler" option
const inputHandlers = {
  sdl: "SDL",
  mmJoystick: "MMJoystick",
  evdev: "Evdev",
};

// Microphone
const isWindows = process.platform === "win32";
const microphoneDevicePrefix = isWindows ? `OpenAL Soft on ` : ``; // Linux typically has no prefix
const microphoneMode = `Standard`;
const microphoneDeviceSeparator = "@@@";
const configAudioPath = `Audio`;
const configMicrophoneTypeKey = "Microphone Type";
const configMicrophoneDevicesKey = "Microphone Devices";

function renameDLSController(arr) {
  return arr.map((item) => {
    let name = item.name;

    // specific name fixes for rpcs3 SDL device names, on windows.
    switch (name) {
      case "PS5 Controller":
        name = "DualSense Wireless Controller";
        break;
      case "Controller (Xbox 360 Wireless Receiver for Windows)":
        name = "Xbox 360 Wireless Controller";
        break;
      default:
        break;
    }

    name = getFixedOldDeviceSDLName(item);

    return { ...item, name };
  });
}

function resolveConfigPath(file) {
  try {
    const configPath = path.resolve(rpcs3Path, "config", file);
    loaders.yml(configPath);

    return configPath;
  } catch (e) {
    console.log(
      "RPCS3 - installation doesnÂ´t appear to have a config/ folder. using root folder.\n",
      e.message,
    );

    return path.resolve(rpcs3Path, file);
  }
}

// rpcs3 uses the SDL device names + a number at the end.
// eg.: Xbox Series X Controller 1, DualSense Wireless Controller 1.
// the number is relative to how many of the same controller is connected. it's not a player/position indicator.
function appendNumbersToSDLDeviceNames(arr) {
  const counts = {};
  return arr.map((item) => {
    counts[item.name] = (counts[item.name] || 0) + 1;
    return { ...item, name: `${item.name} ${counts[item.name]}` };
  });
}

// SDL3 on windows now uses xinput when possible, changing some device names to the structure:
// XInput Controller <number>
// eg.: XInput Controller 1, XInput Controller 2.
async function addXinputNameToDevices(arr) {
  if (process.platform !== "win32") {
    return arr;
  }

  const xinput = await import("xinput-ffi");

  const xinputDevices = [];

  for (
    let position = 0;
    position < xinput.constants.XUSER_MAX_COUNT;
    position++
  ) {
    try {
      const device = await xinput.getCapabilitiesEx(position);
      xinputDevices.push(createJoystickFromXinputDevice(device));
    } catch {
      // either the device is not connected or the xinput device could not be identified and we report it as not connected
      // xinputDevices.push(null);
    }
  }

  const assignedXinputIndexes = [];

  return arr.map((item) => {
    const deviceType = item.type;
    const vendorId = item.raw.vendor;
    const productId = item.raw.product;
    const equivalentXinputDeviceIndex = xinputDevices.findIndex(
      (xinputDevice, index) => {
        if (!xinputDevice) {
          return false;
        }

        const xinputDeviceType = getXinputJoystickType(
          xinputDevice.raw.capabilities.dubType,
        );

        const { vendorId: xinputVendorId, productId: xinputProductId } =
          getXinputVendorAndProductIds(
            xinputDevice.raw.vendorId,
            xinputDevice.raw.productId,
          );

        const hasFullMatch =
          xinputDeviceType === deviceType &&
          xinputVendorId === vendorId &&
          xinputProductId === productId;

        const hasVendorAndProduct =
          xinputVendorId === vendorId && xinputProductId === productId;
        const hasVendorAndType =
          xinputDeviceType === deviceType && xinputVendorId === vendorId;

        const hasMatch =
          (hasFullMatch || hasVendorAndProduct || hasVendorAndType) &&
          !assignedXinputIndexes.includes(index);

        if (hasMatch) {
          assignedXinputIndexes.push(index);
        }

        return hasMatch;
      },
    );
    const isXinput = equivalentXinputDeviceIndex > -1;

    if (isXinput) {
      return {
        ...item,
        name: `XInput Controller ${equivalentXinputDeviceIndex + 1}`,
      };
    }
    return item;
  });
}

/*
Wii and PS3 peripherals only work via evdev on Linux.

NAME FIXES AND PREFIXES
- rpcs3 uses the Evdev device names with a "n. " prefix.
- eg.: 2. Xbox Series X Controller, 2. DualSense Wireless Controller
- the number is relative to how many of the same controller is connected.
- only 2nd + devices get the prefix.
- there are also some name fixes needed for certain devices.  
*/

const evdevDevices = [
  hardwareInfo.harmonixDrumControllerForNintendoWii,
  hardwareInfo.harmonixDrumControllerForPS3,
  hardwareInfo.guitarHeroGuitarForPS3,
];

function shouldUseEvdev(manufacturerId, productId) {
  if (process.platform !== "linux") {
    return false;
  }

  return evdevDevices.some((mmJoystickDevice) =>
    isHardware({ manufacturerId, productId }, mmJoystickDevice),
  );
}

function addEvdevInfo(arr) {
  if (process.platform !== "linux") {
    return arr;
  }

  const counts = {};
  return arr.map((item) => {
    counts[item.name] = (counts[item.name] || 0) + 1;

    const isEvdev = shouldUseEvdev(item.raw.vendor, item.raw.product);

    if (!isEvdev) {
      return item;
    }

    let evdevName = getEvdevName(item);

    if (counts[item.name] > 1) {
      evdevName = `${counts[item.name]}. ${evdevName}`;
    }

    return { ...item, evdevMode: isEvdev, evdevName };
  });
}

async function handleSDLJoystickListUpdate(joystickList) {
  // updating device names to match what rpcs3 uses
  const fixedList = await addXinputNameToDevices(
    appendNumbersToSDLDeviceNames(
      renameDLSController(addEvdevInfo(joystickList)),
    ),
  );

  const newConfig = {};
  playerIdentifiers.forEach((identifier, position) => {
    const joystick = fixedList[position];

    // setting non-connected positions as empty
    if (!joystick) {
      newConfig[identifier] = configTemplates.Empty;
      return;
    }

    newConfig[identifier] = structuredClone(
      configTemplates[joystick.type] ?? configTemplates.Empty,
    );

    try {
      let handler = inputHandlers.sdl;
      let device = joystick.name;

      if (
        mmjoystick.shouldUseMMJoystick(
          joystick.raw.vendor,
          joystick.raw.product,
        )
      ) {
        const mmJoystickDevice = `Joystick #${mmjoystick.getMMJoystickIndex(
          joystick.raw.vendor,
          joystick.raw.product,
        )}`;

        device = mmJoystickDevice;
        handler = inputHandlers.mmJoystick;
      } else if (joystick.evdevMode) {
        device = joystick.evdevName;
        handler = inputHandlers.evdev;
      }

      newConfig[identifier].Device = device;
      newConfig[identifier].Handler = handler;
    } catch (e) {
      console.error(
        "RPCS3 - Device couldn't be configured properly -",
        joystick.name,
      );
      console.error(e);
    }
  });

  savers.yml(newConfig, inputConfigFileName);
  console.log("RPCS3 - Input settings saved at", inputConfigFileName);
  savers.yml(getActiveInputProfileObject(), activeProfileFileName);
  console.log("RPCS3 - Input profile settings saved at", activeProfileFileName);
}

function handleMicrophoneListUpdate(microphoneList) {
  let currentConfig = loaders.yml(generalConfigFileName);

  const slots = [
    microphoneList[0],
    microphoneList[1],
    microphoneList[2],
    microphoneList[3],
  ];

  const microphoneDevices = slots
    .map((mic) =>
      mic
        ? `${microphoneDevicePrefix}${mic.name}${microphoneDeviceSeparator}`
        : `${microphoneDeviceSeparator}`,
    )
    .join("");

  currentConfig[configAudioPath][configMicrophoneTypeKey] = microphoneMode;
  currentConfig[configAudioPath][configMicrophoneDevicesKey] =
    microphoneDevices;

  savers.yml(currentConfig, generalConfigFileName);

  console.log("RPCS3 - Microphone settings saved at", generalConfigFileName);

  const customConfigs = customConfigsPath;
  if (fs.existsSync(customConfigs)) {
    fs.readdirSync(customConfigs).forEach((file) => {
      if (file.endsWith(".yml") || file.endsWith(".yaml")) {
        const customConfigPath = path.join(customConfigs, file);
        const customConfig = loaders.yml(customConfigPath);

        customConfig[configAudioPath][configMicrophoneTypeKey] = microphoneMode;
        customConfig[configAudioPath][configMicrophoneDevicesKey] =
          microphoneDevices;

        savers.yml(customConfig, customConfigPath);

        console.log("RPCS3 - Microphone settings saved at", customConfigPath);
      }
    });
  }
}

const rpcs3 = {
  handleJoystickListUpdate(joystickList) {
    handleSDLJoystickListUpdate(joystickList);
  },
  handleMicrophoneListUpdate,
};

export default rpcs3;
